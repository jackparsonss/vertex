// Code generated by engine.go; DO NOT EDIT.
package generated

import (
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"
	"reflect"
	
	// Import the main package to access the original types
	"github.com/jackparsonss/vertex/cmd/{{ .PackageName }}"
)

// Map to store service instances
var serviceInstances = make(map[string]interface{})

// StartServer starts the HTTP server for the generated functions
func StartServer() {
	// Initialize service instances
	{{range $structName, $funcs := .StructFuncs}}
	if _, exists := serviceInstances["{{$structName}}"]; !exists {
		// Try to find a New{{$structName}} constructor in the main package
		constructor := reflect.ValueOf({{$.PackageName}}.New{{$structName}})
		if constructor.IsValid() && !constructor.IsNil() {
			serviceInstances["{{$structName}}"] = constructor.Call(nil)[0].Interface()
		} else {
			fmt.Printf("Warning: No constructor found for %s, service endpoints may fail\n", "{{$structName}}")
		}
	}
	{{end}}

	{{range .AllFunctions}}http.HandleFunc("{{.Path}}", {{.Name}}Handler)
	{{end}}
	fmt.Println("Server starting on port 8080...")
	if err := http.ListenAndServe(":8080", nil); err != nil {
		fmt.Printf("Server error: %v\n", err)
	}
}

{{range .AllFunctions}}
// {{.Name}}Handler handles HTTP requests for the {{.Name}} function
func {{.Name}}Handler(w http.ResponseWriter, r *http.Request) {
	if r.Method != "{{.Method}}" {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var (
		{{range .Params}}{{.Name}} {{.Type}}
		{{end}}
		err error
	)

	{{if eq .Method "GET"}}
	// Parse query parameters
	query := r.URL.Query()
	{{range .Params}}
	{{if eq .Type "string"}}
	{{.Name}} = query.Get("{{.Name}}")
	{{else if eq .Type "int"}}
	if {{.Name}}Str := query.Get("{{.Name}}"); {{.Name}}Str != "" {
		{{.Name}}64, err := strconv.ParseInt({{.Name}}Str, 10, 64)
		if err != nil {
			http.Error(w, "Invalid parameter: {{.Name}}", http.StatusBadRequest)
			return
		}
		{{.Name}} = int({{.Name}}64)
	}
	{{end}}
	{{end}}
	{{else}}
	// Parse JSON body
	var requestBody map[string]interface{}
	if err := json.NewDecoder(r.Body).Decode(&requestBody); err != nil {
		http.Error(w, "Failed to parse request body", http.StatusBadRequest)
		return
	}

	{{range .Params}}
	{{if eq .Type "string"}}
	if val, ok := requestBody["{{.Name}}"].(string); ok {
		{{.Name}} = val
	} else {
		http.Error(w, "Invalid parameter: {{.Name}}", http.StatusBadRequest)
		return
	}
	{{else if eq .Type "int"}}
	if val, ok := requestBody["{{.Name}}"].(float64); ok {
		{{.Name}} = int(val)
	} else {
		http.Error(w, "Invalid parameter: {{.Name}}", http.StatusBadRequest)
		return
	}
	{{end}}
	{{end}}
	{{end}}

	// Call the function or method
	{{if .IsMethod}}
	serviceInstance, ok := serviceInstances["{{.StructName}}"]
	if !ok {
		http.Error(w, "Service instance not found", http.StatusInternalServerError)
		return
	}

	// Find and call the method using reflection
	service := reflect.ValueOf(serviceInstance)
	method := service.MethodByName("{{.Name}}")
	if !method.IsValid() {
		http.Error(w, "Method not found", http.StatusInternalServerError)
		return
	}

	// Prepare arguments
	args := []reflect.Value{
		{{range .Params}}reflect.ValueOf({{.Name}}),
		{{end}}
	}
	
	// Call the method
	results := method.Call(args)
	if len(results) == 0 {
		http.Error(w, "Method did not return any value", http.StatusInternalServerError)
		return
	}
	
	result := results[0].Interface()
	{{else}}
	// Call standalone function from the main package
	fnValue := reflect.ValueOf({{$.PackageName}}.{{.Name}})
	if !fnValue.IsValid() {
		http.Error(w, "Function not found", http.StatusInternalServerError)
		return
	}
	
	// Prepare arguments
	args := []reflect.Value{
		{{range .Params}}reflect.ValueOf({{.Name}}),
		{{end}}
	}
	
	// Call the function
	results := fnValue.Call(args)
	if len(results) == 0 {
		http.Error(w, "Function did not return any value", http.StatusInternalServerError)
		return
	}
	
	result := results[0].Interface()
	{{end}}

	// Return the result as JSON
	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(result); err != nil {
		http.Error(w, "Failed to encode response", http.StatusInternalServerError)
	}
}
{{end}}
