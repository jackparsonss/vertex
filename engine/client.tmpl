// Code generated by engine.go; DO NOT EDIT.
package generated

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
)

{{range .}}
// {{.Name}} is a client wrapper that calls the server function
func {{.Name}}({{range $index, $param := .Params}}{{if $index}}, {{end}}{{.Name}} {{.Type}}{{end}}) {{.ReturnType}} {
	{{if eq .Method "GET"}}
	// Build query string
	query := url.Values{}
	{{range .Params}}
	{{if eq .Type "string"}}
	query.Set("{{.Name}}", {{.Name}})
	{{else if eq .Type "int"}}
	query.Set("{{.Name}}", strconv.Itoa({{.Name}}))
	{{end}}
	{{end}}

	// Make GET request
	resp, err := http.Get(fmt.Sprintf("http://localhost:8080{{.Path}}?%s", query.Encode()))
	{{else}}
	// Prepare request body
	requestBody, _ := json.Marshal(map[string]interface{}{
		{{range .Params}}"{{.Name}}": {{.Name}},
		{{end}}
	})

	// Make POST request
	resp, err := http.Post("http://localhost:8080{{.Path}}", "application/json", bytes.NewBuffer(requestBody))
	{{end}}
	if err != nil {
		fmt.Printf("Error making HTTP request: %v\n", err)
		return {{if eq .ReturnType "string"}}""{{else if eq .ReturnType "int"}}0{{else}}nil{{end}}
	}
	defer resp.Body.Close()

	// Parse response
	responseData, err := io.ReadAll(resp.Body)
	if err != nil {
		fmt.Printf("Error reading response: %v\n", err)
		return {{if eq .ReturnType "string"}}""{{else if eq .ReturnType "int"}}0{{else}}nil{{end}}
	}

	var responseObj map[string]interface{}
	if err := json.Unmarshal(responseData, &responseObj); err != nil {
		fmt.Printf("Error parsing response: %v\n", err)
		return {{if eq .ReturnType "string"}}""{{else if eq .ReturnType "int"}}0{{else}}nil{{end}}
	}

	{{if eq .ReturnType "string"}}
	if result, ok := responseObj["result"].(string); ok {
		return result
	}
	return ""
	{{else if eq .ReturnType "int"}}
	if result, ok := responseObj["result"].(float64); ok {
		return int(result)
	}
	return 0
	{{else}}
	return responseObj["result"]
	{{end}}
}
{{end}}

